<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Window 3D Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, particleGroup, innerParticleGroup, composer, controls, initialized = false;
        let animationId;
        let time = 0;
        const particleCount = 5000; // Number of particles for outer sphere
        const innerParticleCount = 2000; // Fewer for inner sphere

        // Helper: Setup the 3D scene
        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Orbit controls for drag-to-rotate
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth inertia
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false; // Disable panning for focus on orbit
            camera.position.z = 5;

            // Outer particle system (with fluid motion)
            const outerPositions = new Float32Array(particleCount * 3);
            const outerColors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 1; // Outer radius

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                outerPositions[i * 3] = x;
                outerPositions[i * 3 + 1] = y;
                outerPositions[i * 3 + 2] = z;

                // Brighter violet for outer (more blue-leaning purple)
                outerColors[i * 3] = 0.6 + Math.random() * 0.2; // Medium-high red
                outerColors[i * 3 + 1] = 0.0 + Math.random() * 0.1; // Low green
                outerColors[i * 3 + 2] = 0.9 + Math.random() * 0.1; // High blue
            }

            const outerGeometry = new THREE.BufferGeometry();
            outerGeometry.setAttribute('position', new THREE.BufferAttribute(outerPositions, 3));
            outerGeometry.setAttribute('color', new THREE.BufferAttribute(outerColors, 3));

            const outerMaterial = new THREE.PointsMaterial({
                size: 0.02,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const outerParticles = new THREE.Points(outerGeometry, outerMaterial);
            particleGroup = new THREE.Group();
            particleGroup.add(outerParticles);
            scene.add(particleGroup);

            // Store reference for outer updates
            window.outerPositions = outerGeometry.attributes.position.array;
            window.outerGeometry = outerGeometry;

            // Inner particle system (static, no fluid motion)
            const innerPositions = new Float32Array(innerParticleCount * 3);
            const innerColors = new Float32Array(innerParticleCount * 3);

            for (let i = 0; i < innerParticleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 0.6; // Inner radius

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                innerPositions[i * 3] = x;
                innerPositions[i * 3 + 1] = y;
                innerPositions[i * 3 + 2] = z;

                // Dimmer violet for inner
                innerColors[i * 3] = 0.3 + Math.random() * 0.2; // Medium-low red
                innerColors[i * 3 + 1] = 0.0 + Math.random() * 0.1; // Low green
                innerColors[i * 3 + 2] = 0.5 + Math.random() * 0.2; // Medium-high blue
            }

            const innerGeometry = new THREE.BufferGeometry();
            innerGeometry.setAttribute('position', new THREE.BufferAttribute(innerPositions, 3));
            innerGeometry.setAttribute('color', new THREE.BufferAttribute(innerColors, 3));

            const innerMaterial = new THREE.PointsMaterial({
                size: 0.015, // Slightly smaller
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const innerParticles = new THREE.Points(innerGeometry, innerMaterial);
            innerParticleGroup = new THREE.Group();
            innerParticleGroup.add(innerParticles);
            particleGroup.add(innerParticleGroup); // Nested inside outer group for shared rotation
            scene.add(particleGroup);

            // Ambient light for subtle fill
            const ambientLight = new THREE.AmbientLight(0x101010, 0.1);
            scene.add(ambientLight);

            // Post-processing for bloom glow on particles
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2, // Strength
                0.6, // Radius
                0.3 // Threshold
            );
            composer.addPass(bloomPass);
        }

        // Helper: Resize the shape/viewport
        function resizeShape(forceRender = true) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            if (forceRender) render();
        }

        // Core render loop with animation and fluid motion only for outer
        function render() {
            if (!initialized) return;
            time += 0.016; // ~60fps delta time
            animationId = requestAnimationFrame(render);
            
            // Update controls
            controls.update();
            
            // Fluid-like motion ONLY for outer particles
            const outerPositions = window.outerPositions;
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                let x = outerPositions[idx];
                let y = outerPositions[idx + 1];
                let z = outerPositions[idx + 2];

                // Turbulent noise displacement
                const noiseX = Math.sin(time * 2.5 + i * 0.01) * 0.08;
                const noiseY = Math.cos(time * 3.2 + i * 0.015) * 0.08;
                const noiseZ = Math.sin(time * 1.8 + i * 0.02) * 0.08;

                x += noiseX;
                y += noiseY;
                z += noiseZ;

                // Project back to unit sphere
                const len = Math.sqrt(x * x + y * y + z * z);
                if (len > 0) {
                    x = (x / len) * 1.0;
                    y = (y / len) * 1.0;
                    z = (z / len) * 1.0;
                }

                outerPositions[idx] = x;
                outerPositions[idx + 1] = y;
                outerPositions[idx + 2] = z;
            }
            window.outerGeometry.attributes.position.needsUpdate = true;
            
            // Inner particles: No updates, just rotate with group
            
            // Subtle breathing scale on the group
            particleGroup.scale.setScalar(1 + Math.sin(time * 1.5) * 0.05);
            
            composer.render(); // Use composer for bloom
        }

        // Resize event handler
        function resize() {
            resizeShape();
        }

        // The exact init function from the snippet
        function init() {
            initialized = true;
            setTimeout(() => {
                setupScene();
                resizeShape(false);
                render();
                window.addEventListener("resize", resize);
            }, 500);
        }

        // Start everything
        init();
    </script>
</body>
</html>